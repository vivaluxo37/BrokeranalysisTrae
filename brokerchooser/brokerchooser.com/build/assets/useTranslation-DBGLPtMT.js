import{r as f}from"./Empty-CbVzuLts.js";import{I as F,R as O,B as k,D as z}from"./app-core-DsZLvh-T.js";import{w as R,h as v,l as C,a as P,i as T,b as B}from"./utils-B1GDy_RR.js";try{let t=typeof window<"u"?window:typeof global<"u"?global:typeof globalThis<"u"?globalThis:typeof self<"u"?self:{},n=new t.Error().stack;n&&(t._sentryDebugIds=t._sentryDebugIds||{},t._sentryDebugIds[n]="b0c71035-ce21-4153-9f01-b535ddd12ac3",t._sentryDebugIdIdentifier="sentry-dbid-b0c71035-ce21-4153-9f01-b535ddd12ac3")}catch{}{let t=typeof window<"u"?window:typeof global<"u"?global:typeof globalThis<"u"?globalThis:typeof self<"u"?self:{};t._sentryModuleMetadata=t._sentryModuleMetadata||{},t._sentryModuleMetadata[new t.Error().stack]=Object.assign({},t._sentryModuleMetadata[new t.Error().stack],{"_sentryBundlerPluginAppKey:bc-frontend":!0})}const G=(t,n)=>{const o=f.useRef();return f.useEffect(()=>{o.current=t},[t,n]),o.current},A=(t,n,o,c)=>t.getFixedT(n,o,c),L=(t,n,o,c)=>f.useCallback(A(t,n,o,c),[t,n,o,c]),U=(t,n={})=>{var M,_,S,x;const{i18n:o}=n,{i18n:c,defaultNS:j}=f.useContext(F)||{},e=o||c||z();if(e&&!e.reportNamespaces&&(e.reportNamespaces=new O),!e){R(e,"NO_I18NEXT_INSTANCE","useTranslation: You will need to pass in an i18next instance by using initReactI18next");const a=(i,d)=>T(d)?d:B(d)&&T(d.defaultValue)?d.defaultValue:Array.isArray(i)?i[i.length-1]:i,r=[a,{},!1];return r.t=a,r.i18n={},r.ready=!1,r}(M=e.options.react)!=null&&M.wait&&R(e,"DEPRECATED_OPTION","useTranslation: It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");const y={...k(),...e.options.react,...n},{useSuspense:p,keyPrefix:N}=y;let s=j||((_=e.options)==null?void 0:_.defaultNS);s=T(s)?[s]:s||["translation"],(x=(S=e.reportNamespaces).addUsedNamespaces)==null||x.call(S,s);const l=(e.isInitialized||e.initializedStoreOnce)&&s.every(a=>v(a,e,y)),D=L(e,n.lng||null,y.nsMode==="fallback"?s:s[0],N),h=()=>D,w=()=>A(e,n.lng||null,y.nsMode==="fallback"?s:s[0],N),[E,g]=f.useState(h);let b=s.join();n.lng&&(b=`${n.lng}${b}`);const I=G(b),u=f.useRef(!0);f.useEffect(()=>{const{bindI18n:a,bindI18nStore:r}=y;u.current=!0,!l&&!p&&(n.lng?C(e,n.lng,s,()=>{u.current&&g(w)}):P(e,s,()=>{u.current&&g(w)})),l&&I&&I!==b&&u.current&&g(w);const i=()=>{u.current&&g(w)};return a&&(e==null||e.on(a,i)),r&&(e==null||e.store.on(r,i)),()=>{u.current=!1,e&&(a==null||a.split(" ").forEach(d=>e.off(d,i))),r&&e&&r.split(" ").forEach(d=>e.store.off(d,i))}},[e,b]),f.useEffect(()=>{u.current&&l&&g(h)},[e,N,l]);const m=[E,e,l];if(m.t=E,m.i18n=e,m.ready=l,l||!l&&!p)return m;throw new Promise(a=>{n.lng?C(e,n.lng,s,()=>a()):P(e,s,()=>a())})};export{U as u};
//# sourceMappingURL=useTranslation-DBGLPtMT.js.map
